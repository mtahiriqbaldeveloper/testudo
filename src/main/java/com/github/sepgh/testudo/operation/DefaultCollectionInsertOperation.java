package com.github.sepgh.testudo.operation;

import com.github.sepgh.testudo.ds.Bitmap;
import com.github.sepgh.testudo.ds.Pointer;
import com.github.sepgh.testudo.exception.DeserializationException;
import com.github.sepgh.testudo.exception.IndexExistsException;
import com.github.sepgh.testudo.exception.InternalOperationException;
import com.github.sepgh.testudo.exception.SerializationException;
import com.github.sepgh.testudo.index.DuplicateQueryableIndex;
import com.github.sepgh.testudo.index.UniqueQueryableIndex;
import com.github.sepgh.testudo.index.UniqueTreeIndexManager;
import com.github.sepgh.testudo.scheme.Scheme;
import com.github.sepgh.testudo.serialization.*;
import com.github.sepgh.testudo.storage.db.DatabaseStorageManager;
import com.github.sepgh.testudo.utils.ReaderWriterLock;
import lombok.Getter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Comparator;
import java.util.List;
import java.util.Optional;


// Todo: verification (read README.md)
@Getter
public class DefaultCollectionInsertOperation<T extends Number & Comparable<T>> implements CollectionInsertOperation<T> {
    private static final Logger logger = LoggerFactory.getLogger(DefaultCollectionInsertOperation.class);

    private final Scheme scheme;
    private final Scheme.Collection collection;
    private final ReaderWriterLock readerWriterLock;
    private final CollectionIndexProvider collectionIndexProvider;
    private final DatabaseStorageManager storageManager;
    private final UniqueTreeIndexManager<T, Pointer> clusterIndexManager;

    @SuppressWarnings("unchecked")
    public DefaultCollectionInsertOperation(Scheme scheme, Scheme.Collection collection, ReaderWriterLock readerWriterLock, CollectionIndexProvider collectionIndexProvider, DatabaseStorageManager storageManager) {
        this.scheme = scheme;
        this.collection = collection;
        this.readerWriterLock = readerWriterLock;
        this.collectionIndexProvider = collectionIndexProvider;
        this.storageManager = storageManager;
        this.clusterIndexManager = (UniqueTreeIndexManager<T, Pointer>) collectionIndexProvider.getClusterIndexManager();
    }

    @SuppressWarnings("unchecked")
    @Override
    public <V> V execute(V v) throws SerializationException, InternalOperationException, DeserializationException {
        ModelSerializer modelSerializer = new ModelSerializer(v);
        byte[] serialized = modelSerializer.serialize();
        byte[] bytes = this.execute(serialized);
        return (V) new ModelDeserializer<>(v.getClass()).deserialize(bytes);
    }

    protected Pointer storeBytes(byte[] bytes) throws InternalOperationException {
        return storageManager.store(this.scheme.getId(), this.collection.getId(), scheme.getVersion(), bytes);
    }

    // Todo: good idea to have this method as public interface? read README.md
    @Override
    public byte[] execute(byte[] bytes) throws InternalOperationException, DeserializationException, SerializationException {
        try {
            readerWriterLock.getWriteLock().lock();
            // Todo: we better check for unique field values first, before any insertions  read README.md
            handleAutoGeneratedPrimaryKey(bytes);
            Pointer pointer = this.storeBytes(bytes);
            final T key = this.storeClusterIndex(pointer);
            this.storeFieldIndexes(bytes, key, pointer);
            return bytes;
        } finally {
            readerWriterLock.getWriteLock().unlock();
        }

    }

    private <K extends Comparable<K>> void handleAutoGeneratedPrimaryKey(byte[] bytes) throws InternalOperationException, DeserializationException, SerializationException {
        Optional<Scheme.Field> primaryKeyOptional = collection.getFields().stream().filter(field -> field.isIndexed() && field.getIndex().isPrimary()).findFirst();

        if (primaryKeyOptional.isEmpty())
            return;

        Scheme.Field field = primaryKeyOptional.get();

        if (!field.getIndex().isAutoIncrement())
            return;

        UniqueQueryableIndex<K, T> uniqueIndexManager = (UniqueQueryableIndex<K, T>) collectionIndexProvider.getUniqueIndexManager(field);
        K pk = uniqueIndexManager.nextKey();

        Serializer<K> serializer = (Serializer<K>) SerializerRegistry.getInstance().getSerializer(field.getType());
        CollectionSerializationUtil.setValueOfField(collection, field, bytes, serializer.serialize(pk));
    }


    @SuppressWarnings("unchecked")
    private <K extends Comparable<K>> void storeFieldIndexes(byte[] bytes, T clusterId, Pointer pointer) throws InternalOperationException, DeserializationException, SerializationException {
        Bitmap<Integer> nullsBitmap = CollectionSerializationUtil.getNullsBitmap(collection, bytes);

        int fieldIndex = -1;
        List<Scheme.Field> fields = collection.getFields();
        fields.sort(Comparator.comparingInt(Scheme.Field::getId));

        for (Scheme.Field field : fields) {
            fieldIndex++;
            if (!field.isIndexed())
                continue;

            try {
                if (field.getIndex().isUnique() || field.getIndex().isPrimary()) {
                    UniqueQueryableIndex<K, T> uniqueIndexManager = (UniqueQueryableIndex<K, T>) collectionIndexProvider.getUniqueIndexManager(field);
                    if (field.isNullable() && nullsBitmap.isOn(fieldIndex)) {
                        uniqueIndexManager.addNull(clusterId);
                    } else {
                        uniqueIndexManager.addIndex(
                                CollectionSerializationUtil.getValueOfFieldAsObject(
                                        collection,
                                        field,
                                        bytes
                                ),
                                clusterId
                        );
                    }
                } else {
                    DuplicateQueryableIndex<?, T> duplicateIndexManager = (DuplicateQueryableIndex<?, T>) collectionIndexProvider.getDuplicateIndexManager(field);

                    if (field.isNullable() && nullsBitmap.isOn(fieldIndex)) {
                        duplicateIndexManager.addNull(clusterId);
                    } else {
                        duplicateIndexManager.addIndex(
                                CollectionSerializationUtil.getValueOfFieldAsObject(
                                        collection,
                                        field,
                                        bytes
                                ),
                                clusterId
                        );
                    }
                }
            } catch (InternalOperationException | DeserializationException e) {
                try {
                    clusterIndexManager.removeIndex(clusterId);
                } catch (InternalOperationException ex) {
                    logger.error("Failed to store index, but also failed to rollback cluster id. Root error: {}, rollback error: {}", e.getMessage(), ex.getMessage());
                    throw e;
                }

                try {
                    storageManager.remove(pointer);
                } catch (InternalOperationException ep) {
                    logger.error("Failed to store index, but also failed to remove object from storage manager. Root error {}, storage manager removal error: {}", e.getMessage(), ep.getMessage());
                }

                throw e;
            }
        }
    }

    private T storeClusterIndex(Pointer pointer) throws InternalOperationException {
        T key = null;

        boolean stored = false;
        while (!stored) {
            try {
                key = clusterIndexManager.nextKey();
                clusterIndexManager.addIndex(key, pointer);
                stored = true;
            } catch (IndexExistsException | DeserializationException ignored){}
        }
        return key;
    }
}
